Copyright (C) 2022-2024 Andrea G. Monaco

Copying and distribution of this file, with or without modification, are
permitted in any medium without royalty provided the copyright notice and this
notice are preserved.  This file is offered as-is, without any warranty.




Some notes on design choices, portability and ANSI conformance of alisp.



__Floating point arithmetic__

The four floating-point types of ANSI CL are all the same type and map to native
C double.  This is allowed by ANSI and was done as a quick implementation
strategy.  Of course, it may change in the future.



__Type checking__

Arguments to standard functions and macros (or result of evaluating arguments to
macros, when applicable) are all type checked.

Values assigned to standard variables (like *PACKAGE*, *READ-BASE* and so on)
are not type checked, so assigning an object of the wrong type will likely crash
the interpreter.

Currently, these behaviors can't be changed.



__Stack overflows__

As a protection against stack overflows in lisp code, al has a limit on stack
depth set by the LISP_STACK_SIZE macro in C.  If that limit is reached, the
interpreter will print an error message and abort to top level.



__Builtin functions and macros__

Builtin macros are like special operators in al: they are treated specially by
the interpreter (which is allowed by ANSI), but an alternate implementation of
the macro in lisp is not provided (which is requested by ANSI instead).
Currently, al is non-conforming in this area.

You can freely redefine standard functions and macros.  If you redefine a
builtin with your lisp code though, there's no way to get the C definition back.
Be careful, you can easily make your image unusable this way.

Also note that the compiler has special knowledge of many builtin macros, so if
you change those to something completely different, you probably want to change
COMPILE too.



__alisp extensions__

al has a small number of non-standard builtins; they are interned in the CL-USER
package.

- *AL-ARGC* (an integer) and *AL-ARGV* (a vector of strings) let you access argc
  and argv of C, respectively, so they contain the number and value of
  command-line arguments passed to the interpreter

- AL-GETENV takes a string and returns the value of the environment variable
  with that name, or NIL if such does not exist

- AL-SYSTEM takes a string or NIL; in the first case it tries executing that
  command, in the second it tells whether an execution environment is actually
  available.  AL-SYSTEM uses system from C, so the precise working depends on
  your C library

- the AL-EXIT function takes an optional integer (defaulting to 0) and exits the
  interpreter with that return value

- the functions AL-PRINT-NO-WARRANTY and AL-PRINT-TERMS-AND-CONDITIONS print
  legal information

- the function AL-DUMP-BINDINGS takes no arguments and returns a list with all
  the non-global live variable bindings, starting with the most recently
  established.  Each binding is a list containing the symbol, the value, the
  type of the binding (:LEXICAL or :SPECIAL); for lexical bindings, there's also
  a fourth element of T if the binding is in scope at that moment.  This
  function is intended to be called in the debugger, but works everywhere

- the function AL-DUMP-FUNCTION-BINDINGS does the same thing as
  AL-DUMP-BINDINGS, but with local function bindings

- the function AL-DUMP-FIELDS takes either a structure object, a standard object
  or a condition object and dumps the slots of that object as a list.  Each slot
  is represented as a symbol with its name, if it is unbound, or as a name-value
  pair, if it is bound

- the special operators AL-LOOPY-DESTRUCTURING-BIND and AL-LOOPY-SETQ are
  similar to DESTRUCTURING-BIND and SETQ respectively, but they allow the kind
  of destructuring that LOOP uses, which has more lax rules than
  DESTRUCTURING-BIND.  In particular, you can provide more or less elements in
  the template than values, and you can put a NIL in the template to ignore the
  corresponding subtree

- the functions AL-START-PROFILING, AL-STOP-PROFILING, AL-CLEAR-PROFILING and
  AL-REPORT-PROFILING govern the profiler, see "Profiling".



__Literal objects__

In alisp, the reader always produces fresh objects.  Therefore modifying
literals, albeit undefined by ANSI, works as expected.  You can also modify the
result of a backquote expression.

Of course, such undefined behavior should be avoided if you want best
portability.



__Setting an undefined variable__

Doing SETQ or SETF on an undefined variable is undefined in ANSI, but it is
accepted by many implementations.  In al, this causes the variable to be
proclaimed special, so it is equivalent to a DEFPARAMETER.



__Arrays__

All arrays are adjustable in alisp.  As long as it's an interpreter, there's no
reason to do otherwise.



__Structures__

Redefining a structure type works fine, despite being undefined in ANSI.  But if
you redefine a structure class as something other than a structure, then calling
the constructor or accessors of the previous definition will cause a crash.



__Pathnames__

The pathname API of Common Lisp is very complex, so I chose the simplest
interpretation.  The only meaningful component of a pathname is the name, the
others are ignored.  The truename of a file is just the name, there's no
resolution.



__File operations__

PROBE-FILE does not work very well.  It tries to open the file for reading and
returns NIL if it can't, so it may return NIL even just for lack of permissions.
In the future I will probably add an optional use of POSIX api for better file
operations.



__Streams__

No stream is deemed interactive in alisp.



__Language of implementation__

The alisp codebase should be valid C89, to the best of my knowledge.
Unfortunately, the whole alisp is not C89, since libgmp, which is a required
dependency, seemingly is not.  I will remove the dependency on libgmp at some
point.  I don't know about libreadline, but you can still build without it.



__Loading cl.lisp__

If you don't load cl.lisp, you still have a decent and self-sufficient subset of
Common Lisp.



__Number bases__

*READ-BASE* works correctly, so you can read numbers in any base from 2 to 36.
*PRINT-BASE* instead only works with the bases 8, 10, 16, due to a limitation of
libgmp.



__Character encoding__

al expects its input in UTF-8 and stores strings in the same encoding.  (Note
that UTF-8 is compatible with ASCII, but not with ISO-8859).  If al gets input
in a different encoding, it might still work somewhat, as long as it understands
basic macro characters, except for things like counting the characters in a
string or accessing characters by index.

Input that is not well-formed UTF-8 may cause incorrect behavior in string
manipulation functions, but should not cause a crash.



__Garbage collection__

For garbage collection, alisp uses the algorithm described in "A cyclic
reference counting algorithm and its proof" by Pepels, van Eekelen, Plasmeijer
(1988).  This is a kind of enhanced reference counting that also collects loops.
The paper contains a proof of termination and correctness.  I don't know of
other implementations using this, so this is somewhat experimental.

Constants defined with DEFCONSTANT are skipped when doing traversals of the
reference graph, so defining constants has true performance benefits.

Packages are also skipped in reference counting.



__The ROOM function__

Calling ROOM shows the number of living objects of various types.  T means all
living objects; FUNCTION also includes macros.



__Profiling__

al has a basic profiler.  You can start profiling with AL-START-PROFILING, which
introduces some overhead, and stop it with AL-STOP-PROFILING.

If you later start profiling again, al will keep adding to the previous data;
calling AL-CLEAR-PROFILING clears all data.

AL-REPORT-PROFILING returns a list in which each element is a list which
contains a name, a counter of all the times that function or macro has been
called, and all the time spent in that function or macro (including the time
spent in all descendants in the call graph).  For functions, the time doesn't
include evaluation of arguments.  For macros, the time includes both expansion
and evaluation of result.

The profiler has a few limitations: generic functions, structure constructor and
accessors, condition readers, functions obtained as macro functions and macros
defined with macro functions are not tracked.



__Debugging__

Stepping is always available in the debugger, no matter if you enter it with
BREAK or in any other way.  The following commands are available:

- N executes the next form and then breaks again

- S steps inside the next form and breaks; for function forms, it will first
  step in the argument forms; for unexpanded macro forms, it will first step in
  the macro expansion process, then in the resulting form

- C continues execution at normal speed

- H or ? display help.

When the debugger is entered due to stepping, the result of evaluating the last
form is displayed preceded by " -> ", then a blank line, then the next form is
showed.



__Minor details__

In functions that take both a :TEST and :TEST-NOT argument, the former takes
precedence.
