Copyright (C) 2022-2024 Andrea G. Monaco

Copying and distribution of this file, with or without modification, are
permitted in any medium without royalty provided the copyright notice and this
notice are preserved.  This file is offered as-is, without any warranty.




Some notes on design choices, portability and ANSI conformance of alisp.



__Floating point arithmetic__

The four floating-point types of ANSI CL are all the same type and map to native
C double.  This is allowed by ANSI and was done as a quick implementation
strategy.  Of course, it may change in the future.



__Type checking__

Arguments to standard functions and macros (or result of evaluating arguments to
macros, when applicable) are all type checked.

Values assigned to standard variables (like *PACKAGE*, *READ-BASE* and so on)
are not type checked, so assigning an object of the wrong type will likely crash
the interpreter.

Currently, these behaviors can't be changed.



__Stack overflows__

alisp makes no attempt to intercept stack overflows of lisp code; if your code
has an endless recursion, or a very high call depth, the interpreter will crash.

Ideally, al should only crash in these two cases: for a stack overflow in lisp
code, or after a wrong assignment to a standard variable (see "Type checking").



__Builtin macros__

Builtin macros are like special operators in al: they are treated specially by
the interpreter (which is allowed by ANSI), but an alternate implementation of
the macro in lisp is not provided (which is requested by ANSI instead).
Currently, al is non-conforming in this area.



__Literal objects__

In alisp, the reader always produces fresh objects.  Therefore modifying
literals, albeit undefined by ANSI, works as expected.  You can also modify the
result of a backquote expression.

Of course, such undefined behavior should be avoided if you want best
portability.



__Setting an undefined variable__

Doing SETQ or SETF on an undefined variable is undefined in ANSI, but it is
accepted by many implementations.  In al, this causes the variable to be
proclaimed special, so it is equivalent to a DEFPARAMETER.



__Language of implementation__

The alisp codebase should be valid C89, to the best of my knowledge.
Unfortunately, the whole alisp is not C89, since libgmp, which is a required
dependency, seemingly is not.  I will remove the dependency on libgmp at some
point.  I don't know about libreadline, but you can still build without it.



__Number bases__

*READ-BASE* works correctly, so you can read numbers in any base from 2 to 36.
*PRINT-BASE* instead only works with the bases 8, 10, 16, due to a limitation of
libgmp.



__Character encoding__

al expects its input in UTF-8 and stores strings in the same encoding.  (Note
that UTF-8 is compatible with ASCII).  If al gets input in a different encoding,
it might still work somewhat, as long as it understands basic macro characters,
except for things like counting the characters in a string or accessing
characters by index.
