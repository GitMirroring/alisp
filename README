Copyright (C) 2022 Andrea G. Monaco

Copying and distribution of this file, with or without modification,
are permitted in any medium without royalty provided the copyright
notice and this notice are preserved.  This file is offered as-is,
without any warranty.



al is a lisp implementation.  Right now it is just an interpreter, but
I will add some compilation later.  I aim for Common Lisp conformance,
but I'm not religious about it.

It's written in C89 and it also compiles with the -ansi option of gcc.

Currently it depends on GNU Readline (optionally) and on GNU Multiple
Precision Arithmetic Library.  It uses autotools for building.


If you have a cloned git repository and the last commit is not a
versioned release, you can execute set-version-from-git.sh to set a
meaningful alisp version in the relevant line of configure.ac.

To build from git, start with

  $ autoreconf -i

(which is not needed in released tarballs) and then run the usual

  $ ./configure

configure only admits --with[out]-readline as options, to build with
line editing or not; also note that the test suite will not work
without readline, for some reason.  Then

  $ make

plus optionally

  # make install


A lisp file named cl.lisp contains many standard definitions.  By
default, this file gets loaded at startup from the current directory,
unless you pass -q or --dont-load-cl.  To load the file manually, run

  al> (load "cl.lisp")

at the al prompt.


There's a test script too.  Run it with

  $ ./test.pl

if you have perl on your machine.  You should expect a 100% success
rate, or maybe some failures if floating-point operations yield
slightly different results on your system.

There's another test script called meta_test.pl that runs test.pl many
times.  I wrote that script because I found that some memory bugs
manifest only a fraction of the times.



__Debugging__

The file al_gdb_debug.py defines a gdb command called al_print_object.
You can use it after importing the file in gdb with the 'source'
command.

If obj is a pointer to struct object, the command works like this

  (gdb) al_print_object obj
  ` (   + #<INTEGER>    , @ (LIST #<INTEGER> #<INTEGER>))
  1  1(1)       1(1) 1(1) 1  1(1)       1(1)       1(1)

The object gets printed nicely and below each component you see its
refcount.  The refcount of a cons cell is printed as N(N) where the
first number is the refcount of the cell and second is that of the
car.




You can reach me at andrea.monaco@autistici.org.
